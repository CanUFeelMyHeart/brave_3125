
# Руководство по работе с ветками в git для начинающих
### конфликты при слиянии веток
## комментарий по работе


### чтобы увидеть список всех веток в нашем репозитории, используем: 
  
  git branch


### чтобы создать ветку используем команду:

git branche 'branchname'

либо

 git checkout -b 'branchname' -  в таком случае мы сразу перемещаемся на вновь созданную ветку.

### для удаления ненужной ветки применяется команда: 

git branche -d 'branchName' - данная команда предварительно проверяет было ли слияние рассматриваемой ветки в какую-либо другую(не теряется ли информация из ветки)

git branche -D 'branchName' - удалит ветку в любом случае


### Команда git merge 
выполняет слияние отдельных направлений разработки, созданных с помощью команды git branch, в единую ветку.

git merge 'branch_name' -(имя ветки *которая*
будет слита с веткой HEAD) 

Если в обеих последовательностях коммитов нет конфликтующих изменений, Git объединит их автоматически.

В большинстве случаев Git самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

болле подробное руководство по решению конфликтов можно найти по ссылке :
[conflict_resolution](https://www.atlassian.com/ru/git/tutorials/using-branches/merge-conflicts)

сюда же оставлю свой пример разрешения конфликта при помощи интерфейса GitKraken :


результат - объединение всей информации

![конфликт_после](before.png)




дабвлю в отсчет вид проекта до удаления отельных веток(которые уже прошли слияние)

![aft_del]( result_afrer_del.png)


и чистую работу после удаления отработавших веток:

![bef_del](  res_bef_del.png)

#    задание к семинару 3
# работа с удаленными репозитоиями

## как связать локальный репозиторй с удаленным:

git clone <ссылка на удаленный репозиторий>

### Что делает
Клонирует переданный репозиторий на ваш компьютер.

Ссылку на удаленный репозиторий можно получить нажав на зеленую кнопку Code на главной странице репозитория на GitHub.

Вместо git clone можно было бы создать пустой локальный git-репозиторий, выполнив команду git init. Затем подключить наш удаленный репозиторий командой

 git remote add origin <ссылка>

 После чего вручную загрузить изменения с удаленного репозитория qкомандой git pull, которую мы рассмотрим ниже. Но зачем делать что-то вручную, если для этого есть автоматизированный инструмент.

 ## git push

 Команда Git push позволяет отправлять локальную ветку на удаленный репозиторий.

 Перед пушем надо зафиксировать текущие изменения, то есть сделать git commit.

Далее для отправки в терминале пишем:

git push origin <branch> 
Вместо branch — имя ветки, которую надо отправить. Чаще всего используется master или main: 

git push origin master 
Такое каждый раз писать слишком громоздко, для этого придумали git push по умолчанию. Для этого единожды набираем предыдущую команду с флагом -u:

git push -u origin master
После этого можно писать более коротко, так как git запомнил, что пушить надо на сервер origin ветку под именем master:

git push

Для того чтобы сделать git push в другую ветку, есть специальный синтаксис, где после имени ветки через двоеточие пишется имя удаленной ветки:


git push origin branch:server_branch
где branch – имя локальной ветки, server_branch – имя удаленной ветки на сервере.

### Отправка всех веток на сервер
Вместо имени ветки пишем  флаг —all: 

git push origin --all
После этого все зафиксированные изменения в ветках отправятся в удаленный репозиторий.

### Отправка текущей ветки
Удобный способ отправить текущую ветку с тем же именем на сервере.

git push origin HEAD 
HEAD указывает на текущую ветку . Тем самым, не надо запоминать имя ветки, на которой вы находитесь.

# git pull

Команда __git pull__ на самом деле представляет собой комбинацию двух других команд: 

*git fetch*    

и

 *git merge*. 
 
 На первом этапе git pull выполняется команда git fetch, ограниченная локальной веткой, на которую указывает HEAD. Сразу после загрузки содержимого команда git pull выполняет слияние. Для слитого содержимого создается новый коммит, а указатель HEAD обновляется и начинает указывать на этот новый коммит.

 более подробную информацию по работе с удаенными репозиторями смотри по ссылке
 
 [удаленные репозитории инстркция](https://smartiqa.ru/courses/git/lesson-6)
